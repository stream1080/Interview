### final 、 finally 、 finalize三个关键字的区别
- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。

- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。

- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾。 

### String StringBuffer StringBuilder区别，底层实现，扩容
- 底层是字符数组，String使用final修饰
- StringBuffer StringBuilder继承
- 可变长度采用扩容机制，扩容后长度为原来的2倍+2


### 一个线程调用两次start方法会发生什么
- Java线程是不允许启动两次的，第二次调用必然会抛出IllegalThreadStateException，这是一种运行时异常

### 如何实现深拷贝
- 重写 clone 方法来实现深拷贝，但是显然代码量实在太大。特别对于属性数量比较多、层次比较深的类而言，每个类都要重写clone方法太过繁琐。
- 通过对象序列化实现深拷贝(推荐)，将对象 序列化 为字节序列后，默认会将该对象的整个对象图进行序列化，再通过 反序列 即可完美地实现深拷贝。

### 虚拟内存是什么

定义：
- 虚拟内存是计算机系统内存管理的一种技术，可以手动设置电脑的虚拟内存
- 使得应用程序认为它拥有连续的可用内存（一个连续的完整内存空间），并将内存扩展到了硬盘空间

虚拟内存作用：
- 使得大型程序编写更容易
- 对真正的物理内存的使用更加高效

### Java的反射机制在实际项目中应用广泛，常见的应用场景有：

- 使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；
- 多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；
- 面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。

### AOP动态代理
- Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy,去创建代理对象，而对于没有实现接口的对象，就无法使用JDK Proxy去进行代理了，
- 这时候Spring AOP会使用Cglib，这时候Spring AOP会使用Cglib生成一个被代理对象的子类来作为代理

### TreeMap的底层原理

TreeMap基于红黑树（Red-Black tree）实现。映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作containsKey、get、put、remove方法，它的时间复杂度是log(N)。

TreeMap包含几个重要的成员变量：root、size、comparator。其中root是红黑树的根节点。它是Entry类型，Entry是红黑树的节点，它包含了红黑树的6个基本组成：key、value、left、right、parent和color。Entry节点根据根据Key排序，包含的内容是value。Entry中key比较大小是根据比较器comparator来进行判断的。size是红黑树的节点个数。


### Java基本数据类型
- byte：1字节（8位），数据范围是 -2^7 ~ 2^7-1。
- short：2字节（16位），数据范围是 -2^15 ~ 2^15-1。
- int：4字节（32位），数据范围是 -2^31 ~ 2^31-1。
- long：8字节（64位），数据范围是 -2^63 ~ 2^63-1。
- float：4字节（32位），数据范围大约是 -3.4*10^38 ~ 3.4*10^38。
- double：8字节（64位），数据范围大约是 -1.8*10^308 ~ 1.8*10^308。
- char：2字节（16位），数据范围是 \u0000 ~ \uffff。
- boolean：Java规范没有明确的规定，不同的JVM有不同的实现机制。

### 自动装箱和自动拆箱

- 自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；
- 自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；

### 多态的实现
多态的实现离不开继承，在设计程序时，我们可以将参数的类型定义为父类型。在调用程序时，则可以根据实际情况，传入该父类型的某个子类型的实例，这样就实现了多态。对于父类型，可以有三种形式，即普通的类、抽象类、接口。对于子类型，则要根据它自身的特征，重写父类的某些方法，或实现抽象类/接口的某些抽象方法。